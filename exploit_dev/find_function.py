import ctypes, struct, numpy, sys
from keystone import *

def find(hash):
    CODE = (
        " start:                             "  #
        "   int3                            ;"  #   Breakpoint for Windbg. REMOVE ME WHEN NOT DEBUGGING!!!!
        "   mov   ebp, esp                  ;"  #
        "   sub   esp, 0x200                ;"  #
        "   call  find_kernel32             ;"  #
        "   push  %s                        ;"  #   Function hash
        "   call  find_function             ;"  #
        "   xor   ecx, ecx                  ;"  #   Null ECX
        "   push  ecx                       ;"  #   uExitCode
        "   push  0xffffffff                ;"  #   hProcess
        "   call  eax                       ;"  #   Call Function
        "   call  find_function             ;"  #

        " find_kernel32:                     "  #
        "   xor   ecx, ecx                  ;"  #   ECX = 0
        "   mov   esi,fs:[ecx+30h]          ;"  #   ESI = &(PEB) ([FS:0x30])
        "   mov   esi,[esi+0Ch]             ;"  #   ESI = PEB->Ldr
        "   mov   esi,[esi+1Ch]             ;"  #   ESI = PEB->Ldr.InInitOrder

        " next_module:                      "  #
        "   mov   ebx, [esi+8h]             ;"  #   EBX = InInitOrder[X].base_address
        "   mov   edi, [esi+20h]            ;"  #   EDI = InInitOrder[X].module_name
        "   mov   esi, [esi]                ;"  #   ESI = InInitOrder[X].flink (next)
        "   cmp   [edi+12*2], cx            ;"  #   (unicode) modulename[12] == 0x00?
        "   jne   next_module               ;"  #   No: try next module.

        " find_function:                     "  #
        "   pushad                          ;"  #   Save all registers
                                                #   Base address of kernel32 is in EBX from 
                                                #   Previous step (find_kernel32)
        "   mov   eax, [ebx+0x3c]           ;"  #   Offset to PE Signature
        "   mov   edi, [ebx+eax+0x78]       ;"  #   Export Table Directory RVA
        "   add   edi, ebx                  ;"  #   Export Table Directory VMA
        "   mov   ecx, [edi+0x18]           ;"  #   NumberOfNames
        "   mov   eax, [edi+0x20]           ;"  #   AddressOfNames RVA
        "   add   eax, ebx                  ;"  #   AddressOfNames VMA
        "   mov   [ebp-4], eax              ;"  #   Save AddressOfNames VMA for later

        " find_function_loop:                "  #
        "   jecxz find_function_finished    ;"  #   Jump to the end if ECX is 0
        "   dec   ecx                       ;"  #   Decrement our names counter
        "   mov   eax, [ebp-4]              ;"  #   Restore AddressOfNames VMA
        "   mov   esi, [eax+ecx*4]          ;"  #   Get the RVA of the symbol name
        "   add   esi, ebx                  ;"  #   Set ESI to the VMA of the current symbol name

        " compute_hash:                      "  #
        "   xor   eax, eax                  ;"  #   NULL EAX
        "   cdq                             ;"  #   NULL EDX
        "   cld                             ;"  #   Clear direction

        " compute_hash_again:                "  #
        "   lodsb                           ;"  #   Load the next byte from esi into al
        "   test  al, al                    ;"  #   Check for NULL terminator
        "   jz    compute_hash_finished     ;"  #   If the ZF is set, we've hit the NULL term
        "   ror   edx, 0x0d                 ;"  #   Rotate edx 13 bits to the right
        "   add   edx, eax                  ;"  #   Add the new byte to the accumulator
        "   jmp   compute_hash_again        ;"  #   Next iteration

        " compute_hash_finished:             "  #

        " find_function_compare:             "  #
        "   cmp   edx, [esp+0x24]           ;"  #   Compare the computed hash with the requested hash
        "   jnz   find_function_loop        ;"  #   If it doesn't match go back to find_function_loop
        "   mov   edx, [edi+0x24]           ;"  #   AddressOfNameOrdinals RVA
        "   add   edx, ebx                  ;"  #   AddressOfNameOrdinals VMA
        "   mov   cx,  [edx+2*ecx]          ;"  #   Extrapolate the function's ordinal
        "   mov   edx, [edi+0x1c]           ;"  #   AddressOfFunctions RVA
        "   add   edx, ebx                  ;"  #   AddressOfFunctions VMA
        "   mov   eax, [edx+4*ecx]          ;"  #   Get the function RVA
        "   add   eax, ebx                  ;"  #   Get the function VMA
        "   mov   [esp+0x1c], eax           ;"  #   Overwrite stack version of eax from pushad
        
        " find_function_finished:            "  #
        "   popad                           ;"  #   Restore registers
        "   ret                             ;"  #
    % hash)
    
    # Initialize engine in X86-32bit mode
    ks = Ks(KS_ARCH_X86, KS_MODE_32)

    encoding, count = ks.asm(CODE)
    print("Encoded %d instructions..." % count)

    sh = b""
    for e in encoding:
        sh += struct.pack("B", e)
    shellcode = bytearray(sh)

    shellcode = bytearray(sh)

    ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),
                                            ctypes.c_int(len(shellcode)),
                                            ctypes.c_int(0x3000),
                                            ctypes.c_int(0x40))

    buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)

    ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),
                                        buf,
                                        ctypes.c_int(len(shellcode)))

    print("Shellcode located at address %s" % hex(ptr))
    input("...ENTER TO EXECUTE SHELLCODE...")

    ht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),
                                            ctypes.c_int(0),
                                            ctypes.c_int(ptr),
                                            ctypes.c_int(0),
                                            ctypes.c_int(0),
                                            ctypes.pointer(ctypes.c_int(0)))

    ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht), ctypes.c_int(-1))

def ror_str(byte, count):
    binb = numpy.base_repr(byte, 2).zfill(32)
    while count > 0:
        binb = binb[-1] + binb[0:-1]
        count -= 1
    return (int(binb, 2))

if __name__ == '__main__':
    try:
        esi = sys.argv[1]
    except IndexError:
        print("Usage: %s FUNCTION_NAME" % sys.argv[0])
        sys.exit()

    # Initialize variables
    edx = 0x00
    ror_count = 0

    for eax in esi:
        edx = edx + ord(eax)
        if ror_count < len(esi)-1:
            edx = ror_str(edx, 0xd)
        ror_count += 1

    hash = hex(edx)
    print("%s:%s" % (esi, hash))
    find(hash)
